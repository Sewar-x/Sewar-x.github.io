# 前端部署原理



## **前端手动部署**

### **前端手动发版流程**

1. **本地开发与打包**：
   - 前端开发人员在本地开发环境中编写和测试代码。
   - 当代码开发完成后，使用如`npm run build`或`yarn build`等命令，通过前端项目的构建脚本（通常是Webpack、Rollup等）打包前端代码。
   - 打包过程会生成优化后的静态资源文件，通常包括HTML、CSS、JavaScript等，这些文件被放置在项目的`dist`或`build`目录下。
2. **配置Nginx：**
   - 前端开发人员或系统管理员需要配置Nginx作为静态资源服务器。
   - 在Nginx的配置文件（通常是`nginx.conf`或某个站点特定的配置文件）中，指定静态资源文件的根目录为前端项目的`dist`或`build`目录。
   - 配置Nginx监听特定的端口（如80或443），并设置相应的访问规则，如域名、SSL证书等。
3. **启动Nginx服务：**
   - 根据操作系统和Nginx安装方式的不同，使用相应的命令启动Nginx服务。
   - Nginx开始监听配置的端口，并等待客户端的请求。
4. **部署静态资源：**
   - 将打包生成的静态资源文件（位于`dist`或`build`目录）部署到Nginx配置的根目录下。
   - 这可以通过手动复制文件或使用自动化工具（如FTP客户端、SCP、rsync等）完成。
5. **访问静态资源：**
   - 当用户通过浏览器访问配置好的域名或IP地址时，Nginx会拦截请求，并根据配置提供相应的静态资源文件。
   - 浏览器接收到这些文件后，会解析并渲染页面，从而展示前端应用。
6. **更新与发版：**
   - 当前端代码有更新时，开发人员会重复步骤1到步骤5，以发布新的版本。
   - 在更新过程中，可能需要重启Nginx服务或采用其他方式使配置生效。



### **静态资源服务搭建**

在前后端分离项目中，前端部署服务为：

1. 使用 `nginx` 起一个 web 服务器；
2. 将`dist`文件夹的静态资源放到指定的路径下；
3. 配置下`nginx`访问路径，对于请求接口使用`proxy_pass`进行转发，解决跨域的问题。



### **存在问题**

以上传统的前端手动发版流程存在以下几个问题：

1. **手动操作多，容易出错**：整个流程涉及多个步骤，且大部分需要手动完成，如打包、传输、部署等，这些步骤中容易出现操作失误，导致发版失败或出现问题。
2. **依赖后端人员**：前端开发人员需要将生成的`dist`文件夹交给后端开发人员，再由后端人员部署，这增加了沟通成本和依赖关系，也增加了出错的概率。
3. **缺乏自动化和持续集成/持续部署（CI/CD）**：没有利用自动化工具和CI/CD流程，使得发版过程繁琐且效率低下，也无法保证每次发版的质量和一致性。
4. **缺乏版本控制和追踪**：在手动发版过程中，很难对每次发版的内容和变化进行追踪和管理，这不利于问题排查和版本回滚。

为了解决这些问题，可以考虑引入自动化工具和CI/CD流程（如Jenkins、GitLab CI/CD等），将前端代码和后端代码分开部署，利用版本控制系统（如Git）对代码进行管理和追踪，以提高发版的效率和质量。

同时，也可以考虑使用Docker等容器化技术，将前端和后端代码打包成独立的容器，实现更快速、灵活的部署。

## **前端自动化部署**

### **概念**

前端自动化部署是指通过工具和脚本自动完成前端项目的构建、打包和部署等工作。

目的是减少人工操作，提高效率，降低出错概率。

通过自动化部署，开发人员可以更加专注于业务逻辑的开发，而不需要关心一些繁琐而机械的操作。

### **流程**

前端自动化部署的思路和流程可以大致分为以下几个步骤：

1. **代码提交与版本控制**：前端开发人员编写并测试代码后，将代码提交到版本控制系统（如Git）中。这一步确保了代码的版本管理和追踪。
2. **持续集成（CI）**：当代码提交到版本控制系统后，持续集成工具（如Jenkins、GitLab CI/CD等）会自动触发构建流程。构建过程通常包括代码拉取、依赖安装、代码检查（如linting）、单元测试等步骤。这一步确保了每次构建都是基于最新的代码，并且代码质量符合预设标准。
3. **构建与打包**：构建流程完成后，自动化部署工具会根据项目的配置和需求，对前端项目进行打包。这通常包括压缩JS、CSS文件，生成静态资源文件等。打包后的文件通常会被放置在特定的目录中，准备进行下一步的部署。
4. **持续部署（CD）**：在打包完成后，持续部署工具会自动将打包后的文件部署到目标环境（如测试环境、生产环境等）。部署过程可能包括文件传输（如FTP、SCP等）、环境配置、服务重启等步骤。这一步确保了代码能够自动、快速地部署到目标环境，提高了部署效率。
5. **监控与回滚**：在部署完成后，自动化部署工具会监控应用的运行状态，确保应用能够正常运行。如果出现问题，可以根据预设的策略进行回滚，将应用恢复到之前的状态，保证了应用的稳定性和可靠性。

整个前端自动化部署流程中，工具的选择和配置是关键。

需要根据项目的需求、团队的技术栈和偏好来选择合适的工具和配置。

同时，也需要不断地优化和完善流程，以提高部署效率和质量。

### **方案**

|    工具/方案     |                             思路                             |                             优点                             |                             缺点                             |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **Jenkins**    | Jenkins是一个开源的持续集成/持续部署（CI/CD）工具，可以自动化构建、测试和部署项目。<br />通过配置Jenkins，可以实现在代码提交后自动打包、构建和部署前端项目。 | 高度可配置，支持多种构建工具和插件。<br />支持自动化构建、测试和部署流程。<br />有丰富的社区支持和文档资源。 | 配置相对复杂，需要一定的学习成本。<br /> 可能需要额外的插件或工具来实现某些功能。 |
| **GitLab CI/CD** | GitLab内置了CI/CD功能，可以直接在Git仓库中配置CI/CD流程。<br />通过编写`.gitlab-ci.yml`文件，可以定义自动化构建、测试和部署任务。 | 与GitLab紧密集成，方便管理和配置。<br /> 支持Docker等容器化技术，方便实现环境隔离和部署。<br />提供了丰富的预定义模板和工具，简化配置过程。 | 需要在GitLab中配置和管理CI/CD流程。<br />可能受到GitLab平台本身的限制或影响。 |
|    **Docker**    | Docker是一个容器化技术，可以将前端项目打包成独立的容器，并通过Docker Compose或Kubernetes等工具进行管理和部署。 | 容器化技术可以实现环境隔离和一致性，减少部署错误和兼容性问题。<br />可以快速部署和扩展项目，提高部署效率。- 支持多平台部署，如Linux、Windows等。 | 需要学习和理解Docker和容器化技术的相关知识。<br /> 可能需要额外的配置和管理工作。 |
|   **Netlify**    | Netlify是一个基于云的前端自动化部署平台，支持多种前端框架和工具。<br />通过连接Git仓库，可以自动构建、测试和部署前端项目。 | 提供了简单易用的界面和配置方式，降低了学习成本。<br /> 支持多种前端框架和工具，兼容性好。<br />提供了实时预览和部署日志等功能，方便跟踪和调试。 | 可能需要付费使用高级功能或增加额外的配置。<br />可能受到Netlify平台本身的限制或影响。 |

关于前端自动化部署详细实践方案，可以参考博客：[前端自动部署 | Sewen 博客 (sewar-x.github.io)](https://sewar-x.github.io/projectDeploy/自动构建和部署/)



## **前端部署原理**

### **前端部署发展过程**

![image-20240219105349002](../images/前端手动部署.png)

原始的前端开发过程：

1. 搭建一个静态资源服务器；

2. 将 `index.html` 页面和它的样式文件 `a.css`，用文本编辑器写代码，无需编译，本地预览，确认OK，使用 FPT 上传到服务器，等待用户访问。

3. 访问页面，查看一下网络请求，200状态，访问成功。

   ![image-20240219105947890](../images/前端部署2.png)



以上模式存在问题：`a.css` 通常是变化不大静态资源文件，，如果每次用户访问页面都要加载该文件，很影响性能和浪费带宽。

当第二次访问该文件时候，浏览器会使用 304协商缓存 保存 `a.css` 静态资源文件：

![image-20240219110403273](../images/304缓存.png)

但协商缓存还是要和服务器通信一次，依然浪费带宽。

#### **使用强制缓存**

为了减少通信带宽，通常我们会强制浏览器使用本地缓存（`cache-control/expires`），不要和服务器通信（通过配置响应 `cache-control/expires` 字段控制强制缓存），通过使用强制缓存，浏览器请求如下：

![image-20240219110625381](../images/强制缓存.png)

通过以上强制缓存解决了静态资源频繁请求浪费带宽的问题，但是又引出以下问题：存在缓存的静态资源如何更新？

为了解决缓存静态资源更新问题，后来产生以下解决方案：

#### **静态资源添加版本号**

**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源**

![image-20240219111121296](../images/缓存问题.png)

在 `index.html` 中引入静态资源的标签中，添加 `?.v=1.0.0` 静态资源的版本号；

通过该方法，每次发布版本时， `index.html` 页面中静态资源版本号都会改变：

![image-20240219111544403](../images/发版问题.png)

后来实践中发现以上模式存在问题：页面引用了3个css，而某次上线只改了其中的 `a.css`，如果所有链接都更新版本，就会导致 `b.css`，`c.css` 的缓存也失效，那岂不是又有带宽浪费了？！



#### **文件级别的精确缓存控制**

为了让未更新的静态资源不更新，避免带宽的浪费，必须让url的修改与文件内容关联，也就是说，**只有文件内容变化，才会导致相应 url 的变更**，从而实现文件级别的精确缓存控制。

解决方案：利用 [数据摘要算法](http://baike.baidu.com/view/10961371.htm) 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。（数据摘要算法通过输入相同的明文数据经过相同的消息摘要算法得到相同的[密文](https://baike.baidu.com/item/密文/9684333?fromModule=lemma_inlink)）

![image-20240219112425432](../images/数据摘要算法.png)



通过利用 [数据摘要算法](http://baike.baidu.com/view/10961371.htm) 对文件求摘要信息作为文件版本号，只有当文件内容发生变更时，文件本版号才会更新，因此内容不变的静态资源文件版本号不更改。从而实现对文件更新的精准控制。

#### **动静资源分离部署**

现代互联网企业，为了进一步提升网站性能，提升网站访问速度，通常会把静态资源和动态网页分集群部署，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径：

![image-20240219113116232](../images/动静分离部署.png)

将静态资源和动态网页分集群部署的方案主要思路:

将静态资源（如图片、CSS、JS文件等）和动态网页（如需要后端处理的页面）分别部署在不同的服务器上，以提高系统的性能和可扩展性。具体实现流程如下：

1. **环境准备**：首先，需要准备静态资源服务器和动态网页服务器。静态资源服务器可以使用CDN（内容分发网络）节点或专门的静态文件服务器，而动态网页服务器则可以使用Web应用服务器，如Tomcat、Nginx等。
2. **静态资源部署**：将前端项目中的静态资源文件（如图片、CSS、JS文件等）部署到静态资源服务器上。这些文件通常会被打包成静态资源包，并上传至静态资源服务器的指定目录中。
3. **动态网页部署**：将前端项目中的动态网页文件（如需要后端处理的页面）部署到动态网页服务器上。这些文件通常会经过构建和打包过程，生成可执行的Web应用，并部署到动态网页服务器的指定目录中。
4. **配置服务器**：在静态资源服务器上配置CDN节点或静态文件服务器，确保用户能够正确地访问到静态资源。在动态网页服务器上配置Web应用服务器，确保能够正确地处理动态网页请求。
5. **负载均衡**：为了提高系统的可扩展性和性能，可以配置负载均衡器（如Nginx、HAProxy等）来分发用户请求。负载均衡器可以根据请求的类型（静态资源请求或动态网页请求）将请求转发至相应的服务器上。
6. **访问流程**：当用户访问前端应用时，首先会访问负载均衡器。负载均衡器会根据请求的类型将请求转发至相应的服务器上。如果用户请求的是静态资源，则会直接访问静态资源服务器上的资源；如果用户请求的是动态网页，则会访问动态网页服务器上的Web应用，由后端处理并生成相应的页面返回给用户。

通过这种方式，将静态资源和动态网页分集群部署可以提高系统的性能和可扩展性。静态资源服务器可以快速地响应用户的请求，而动态网页服务器则可以处理复杂的业务逻辑和数据处理。同时，通过负载均衡器的配置，可以实现请求的分发和负载均衡，进一步提高系统的性能和稳定性。

通过将动静资源分离部署，发布流程将如下图：

![image-20240219114010043](../images/动静分离部署2.png)



以上发布版本中，同时改了页面结构和样式，也更新了静态资源对应的url地址，现在要发布代码上线，结果存在以下问题：先上线页面，还是先上线静态资源？

1. **先部署页面，再部署资源**：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。
2. **先部署资源，再部署页面**：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。
   好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。



## **参考资料**

[大公司里怎样开发和部署前端代码？ · Issue #6 · fouber/blog (github.com)](https://github.com/fouber/blog/issues/6)