<template><div><h1 id="vue-ssr" tabindex="-1"><a class="header-anchor" href="#vue-ssr" aria-hidden="true">#</a> VUE-SSR</h1>
<h2 id="预备知识" tabindex="-1"><a class="header-anchor" href="#预备知识" aria-hidden="true">#</a> 预备知识</h2>
<h3 id="单页面应用与多页面应用" tabindex="-1"><a class="header-anchor" href="#单页面应用与多页面应用" aria-hidden="true">#</a> 单页面应用与多页面应用</h3>
<ul>
<li>了解页面渲染模式目的：</li>
</ul>
<h4 id="单页面应用" tabindex="-1"><a class="header-anchor" href="#单页面应用" aria-hidden="true">#</a> 单页面应用</h4>
<ul>
<li>概念</li>
<li>特点</li>
<li>应用</li>
</ul>
<h4 id="多页面应用" tabindex="-1"><a class="header-anchor" href="#多页面应用" aria-hidden="true">#</a> 多页面应用</h4>
<ul>
<li>概念</li>
<li>特点</li>
<li>应用</li>
</ul>
<h3 id="seo" tabindex="-1"><a class="header-anchor" href="#seo" aria-hidden="true">#</a> SEO</h3>
<ul>
<li>
<p>概念：SEO 是搜索引擎优化（Search Engine Optimization）。SEO是指通过对网站进行站内优化和修复(网站Web结构调整、网站内容建设、网站代码优化和编码等)和站外优化。</p>
</li>
<li>
<p>SEO规则：不同搜索引擎对于 SEO 有不同详细规则。</p>
</li>
<li>
<p>目的：</p>
<ul>
<li>提高网站的网站关键词排名以及公司产品的曝光度。通过搜索引擎查找信息是当今网民们寻找网上信息和资源的主要手段。</li>
<li>通过引流增加曝光度。</li>
</ul>
</li>
<li>
<p>SEO 标准：</p>
<p><img src="@source/images/seo标准.png" alt=""></p>
</li>
</ul>
<p><strong>前端 SEO 优化：</strong></p>
<ul>
<li>
<p>添加 TDK ：</p>
<ul>
<li>title：
<ul>
<li>浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）</li>
<li>title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</li>
<li>重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同。</li>
<li>用法：<code v-pre>&lt;title&gt;网站标题&lt;/title&gt;</code></li>
</ul>
</li>
<li>description（内容摘要）:
<ul>
<li>description 是对于一个网页的简要内容概况。</li>
<li>description一般不超过150个字符，描述内容要和页面内容相关。</li>
<li>用法：<code v-pre>&lt;meta name=&quot;Description&quot; Content=&quot;你网页的简述&quot;&gt;</code></li>
</ul>
</li>
<li>keywords（关键词）:
<ul>
<li>主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。</li>
<li>keywords 的每个词都要能在内容中找到相应匹配，才有利于排名。</li>
<li>keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。</li>
<li>用法：<code v-pre>&lt;meta name=&quot;Keywords&quot; Content=&quot;关键词1,关键词2,关键词3,关键词4″&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>添加结构化数据：</p>
<ul>
<li>结构化数据（英文：Structured data）是一种标准化格式，用于提供网页的相关信息并对网页内容进行分类；</li>
<li>作用：增加展示信息，利于排名。结构化数据优化过的网站，在Google搜索中比单一的通过title，url，description三部分展示的信息更多更全，更加有助于排名，而且也更加吸引读者点击，也是Google比较推崇的。</li>
</ul>
</li>
<li>
<p>添加站点地图：</p>
<ul>
<li>站点地图是网站的蓝图，可帮助搜索引擎查找、爬取和索引网站的所有内容。它还会告诉搜索引擎您网站上的哪些页面最重要。</li>
<li>站点地图不是面向用户的，而是面向搜索引擎的。</li>
<li>主要作用是：主动帮助搜索引擎爬取网站内容，告诉搜索引擎哪个页面很重要。</li>
<li>网站地图主要有四种类型：
<ul>
<li>普通XML网站地图：这是迄今为止最常见的网站地图类型。通常以XML Sitemap的形式链接到您网站上的页面。</li>
<li>视频站点地图：专门用于帮助Google了解您页面上的视频内容。</li>
<li>新闻站点地图：帮助Google在“Google新闻”审核过的网站上查找内容。</li>
<li>图片站点地图：帮助Google 查找您网站上托管的所有图片。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码优化：</p>
<ul>
<li>
<p>减少无效代码；</p>
</li>
<li>
<p>html 代码优化：</p>
<ul>
<li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引 擎对抓取长度有限制，保证重要内容肯定被抓取。</li>
<li><code v-pre>&lt;body&gt;</code> 的代码遵循语义化：
<ul>
<li>h1~h6标签多用于标题</li>
<li>ul标签多用于无序列表</li>
<li>ol标签用于有序列表</li>
<li>dl标签用于定义数据列表</li>
<li>em,strong表示强调</li>
<li>span标签是html里面最没有语义的</li>
</ul>
</li>
<li>标签优化：
<ul>
<li><code v-pre>&lt;a&gt;</code> 标签：加上链接说明title，另外对于指向其他网站的链接要加上&quot;rel=nofollow&quot;,表示不要爬取这个链接。</li>
<li><code v-pre>&lt;img&gt;</code>标签应使用alt说明，爬虫对图片的读取有限。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CSS 代码优化：</p>
<ul>
<li>
<p>减少 CSS 结构嵌套</p>
</li>
<li>
<p>隐藏内容元素对SEO影响：display:none 和 overflow:hidden 大量地被使用会被SEO认为作弊</p>
</li>
<li>
<p>使用 display: none 控制 tab 元素显示隐藏，但是  display: none 大量地被使用会被SEO认为作弊</p>
<p>解决方式： 使用 height: 0；控制不显示元素方式代替 display:none；</p>
</li>
</ul>
</li>
<li>
<p>JS 代码优化：</p>
<ul>
<li>重要内容不要用 js 输出：爬虫不会执行 js 获取内</li>
<li>避免内嵌 JS 代码；</li>
<li>少用 iframe：搜索引擎不会抓取 iframe 中的内容。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内容优化：增加页面有效内容</p>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<p><a href="http://www.tianying888.com/gongsidongtai/70326.html" target="_blank" rel="noopener noreferrer">网站TDK对SEO有什么影响<ExternalLinkIcon/></a></p>
<p><a href="https://developers.google.com/search/docs/guides/search-gallery?hl=zh-cn" target="_blank" rel="noopener noreferrer">google 结构化数据介绍<ExternalLinkIcon/></a></p>
<p><a href="https://support.google.com/webmasters/answer/156184?hl=zh-Hans" target="_blank" rel="noopener noreferrer">了解站点地图<ExternalLinkIcon/></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/144078265" target="_blank" rel="noopener noreferrer">什么是站点地图？如何优化站点地图？<ExternalLinkIcon/></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/76258427" target="_blank" rel="noopener noreferrer">浅谈Google SEO里的结构化数据优化<ExternalLinkIcon/></a></p>
<h3 id="pwa-应用" tabindex="-1"><a class="header-anchor" href="#pwa-应用" aria-hidden="true">#</a> PWA 应用</h3>
<ul>
<li>
<p>概念：</p>
<ul>
<li>PWA 全称 Progressive Web App，即渐进式 WEB 应用。</li>
<li>PWA 应用是一个网页, 可以通过搜索引擎发现。</li>
<li>使用 Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。</li>
</ul>
</li>
<li>
<p>PWA 特性：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#discoverable" target="_blank" rel="noopener noreferrer">可发现（Discoverable）<ExternalLinkIcon/></a>, 可以通过搜索引擎发现。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#installable" target="_blank" rel="noopener noreferrer">可安装（Installable）<ExternalLinkIcon/></a>, 可以出现在设备的主屏幕。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#linkable" target="_blank" rel="noopener noreferrer">可链接（Linkable）<ExternalLinkIcon/></a>, 可以简单地通过 URL 分享。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#network_independent" target="_blank" rel="noopener noreferrer">独立于网络（Network independent）<ExternalLinkIcon/></a>, 可以在离线状态或者是在网速很差的情况下运行。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#progressive" target="_blank" rel="noopener noreferrer">渐进式（Progressive）<ExternalLinkIcon/></a>, 在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#re-engageable" target="_blank" rel="noopener noreferrer">可重入（Re-engageable）<ExternalLinkIcon/></a>, 无论何时有新的内容，都可以发送通知。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#responsive" target="_blank" rel="noopener noreferrer">响应式（Responsive）<ExternalLinkIcon/></a>, 在任何具有屏幕和浏览器的设备上可以正常使用——包括手机、平板电脑、笔记本、电视、冰箱等。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Introduction#Advantages_of_web_applications#safe" target="_blank" rel="noopener noreferrer">安全（Safe）<ExternalLinkIcon/></a>, 在用户、应用和服务器之间的连接是安全的，第三方无法访问你的敏感数据。</li>
</ul>
</li>
<li>
<p>主要结构：</p>
<ul>
<li>提供 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/App_structure#app_shell_%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener noreferrer">App Shell<ExternalLinkIcon/></a> 基本外壳可以添加至主屏幕。使用 Manifest 实现。</li>
<li>提供离线缓存功能。使用 service worke 实现。</li>
<li>提供消息推送功能。使用 service worke 实现。</li>
</ul>
</li>
</ul>
<h4 id="app-shell" tabindex="-1"><a class="header-anchor" href="#app-shell" aria-hidden="true">#</a> App Shell</h4>
<ul>
<li>概念：提供一个 Web APP 的外壳，然后缓存它，以便在后续访问时可以离线使用，然后再加载应用程序的所有内容。这样，下次有人从设备访问应用程序时，UI 立即从缓存加载；如果缓存数据不可用的话，再从服务器请求新内容。
<ul>
<li>从 HTML 的角度，App Shell 就是 content 节之外的内容。再使用 JS 处理模板生成 content 中的内容。</li>
</ul>
</li>
<li>优点：
<ul>
<li>这种结构的页面很快，给用户的感觉也很快：用户会立即看到内容而不是加载动画或空白页。</li>
<li>如果网络连接不可用，允许离线访问网站。</li>
<li>网站感觉就像一个原生应用，交互及时、性能可靠。</li>
</ul>
</li>
</ul>
<h4 id="manifest" tabindex="-1"><a class="header-anchor" href="#manifest" aria-hidden="true">#</a> Manifest</h4>
<p>可安装网站需要满足以下条件：</p>
<ul>
<li>一份网页清单，填好<a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Add_to_home_screen#manifest" target="_blank" rel="noopener noreferrer">正确的字段<ExternalLinkIcon/></a></li>
<li>网站的协议必须是安全的（即使用 HTTPS 协议）</li>
<li>一个在设备上代表应用的图标</li>
<li>一个注册好的 Service Worker，可以让应用离线工作（这仅对于安卓设备上的 Chrome 浏览器是必需的）</li>
</ul>
<p>Manifest: 离线访问的关键在于一份网页清单，它通过 JSON 形式列举了网站的所有信息。</p>
<p>它通常位于网页应用的根目录，包含一些有用的信息，比如应用的标题、在移动设备操作系统上显示的代表该应用的不同大小的图标（例如主屏图标）的路径，和用于加载页或启动画面的背景颜色。浏览器需要这些信息来安装 web 应用并使其在主屏上显示。</p>
<p>参考资料：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Installable_PWAs#%E6%B8%85%E5%8D%95%E6%96%87%E4%BB%B6_(manifest)" target="_blank" rel="noopener noreferrer">清单文件 (Manifest)<ExternalLinkIcon/></a></p>
<h4 id="service-worker" tabindex="-1"><a class="header-anchor" href="#service-worker" aria-hidden="true">#</a> Service Worker</h4>
<ul>
<li>
<p>概念： Service Worker 是浏览器和网络之间的虚拟代理。</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>运行在一个与页面 JavaScript 主线程独立的线程上，单独的作用域范围，单独的运行环境和执行线程。</p>
</li>
<li>
<p>不能操作页面 DOM。但可以通过事件机制来处理。</p>
</li>
<li>
<p>不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</p>
</li>
<li>
<p>API 是异步非阻塞的，并且可以在不同的上下文之间发送和接收信息。</p>
</li>
<li>
<p>它设计为完全异步，同步API（如<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XHR<ExternalLinkIcon/></a>和<a href="https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/Web_Storage_API" target="_blank" rel="noopener noreferrer">localStorage<ExternalLinkIcon/></a>）不能在service worker中使用。</p>
</li>
<li>
<p>事件驱动型服务线程。可分配给 Service Worker 一些任务，并通过基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise<ExternalLinkIcon/></a> 的方法在任务完成时收到结果。</p>
</li>
<li>
<p>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)。</p>
<ul>
<li>
<blockquote>
<p>为什么要求网站必须是HTTPS？</p>
<p>因为service worker权限太大能拦截所有页面的请求，使用 http 的网站安装 service worker 很容易被攻击,修改网络请求的能力暴露给中间人攻击会非常危险</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Service Worker 使用场景：</p>
<ul>
<li><a href="https://github.com/slightlyoff/BackgroundSync" target="_blank" rel="noopener noreferrer">后台同步<ExternalLinkIcon/></a>：启动一个service worker即使没有用户访问特定站点，也可以更新缓存</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="noopener noreferrer">响应推送<ExternalLinkIcon/></a>：启动一个service worker向用户发送一条信息通知新的内容可用</li>
<li>后台数据同步</li>
<li>响应来自其它源的资源请求</li>
<li>集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据</li>
<li>在客户端进行 CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的）</li>
<li>后台服务钩子</li>
<li>自定义模板用于特定URL模式</li>
<li>性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片</li>
</ul>
</li>
<li>
<p>生命周期：注册、sw.js 文件下载、安装，激活。</p>
<ul>
<li>流程图<img src="@source/images/service-work-lifrcycle.png" alt=""></li>
</ul>
</li>
<li>
<p>安全性问题</p>
<ul>
<li>跨域请求支持：  SW 可以拦截它作用域内的所有请求，跨域资源也不例外，但是浏览器默认对跨域资源发起的是 no-cors 请求，得到的 response 是 opaque 的， 所以会导致我们无法判断跨域请求是否成功，以便进行缓存，因此我们需要修改 fetch 请求头部信息，添加 mode：’cors’ 标记。</li>
<li>no-cors：该模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源，但是首先有个前提条件，就是请求的 method 只能是 HEAD 、GET 、POST 。此外，如果 ServiceWorkers 拦截了这些请求，它不能随意添加或者修改除这些之外 Header 属性。第三，JS 不能访问 Response 对象中的任何属性，这确保了跨域时 ServiceWorkers 的安全和隐私信息泄漏问题。</li>
<li>opaque：Response 对象中 type 属性的值 ， 在 ‘no-cors’ 模式下请求了跨域资源，依靠服务端来做限制。</li>
</ul>
</li>
</ul>
<h4 id="离线缓存" tabindex="-1"><a class="header-anchor" href="#离线缓存" aria-hidden="true">#</a> 离线缓存</h4>
<ul>
<li>Service Workers  缓存：Service Workers  能够拦截 HTTP 请求，进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。
<ul>
<li>与 HTTP 缓存比较：Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>**注册：**使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerContainer/register" target="_blank" rel="noopener noreferrer"><code v-pre>ServiceWorkerContainer.register()</code><ExternalLinkIcon/></a> 方法在该站点注册。其内容在 sw.js 文件中，可以在注册成功后执行。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'serviceWorker'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'/sw.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>**安装：**sw.js 监听 install 事件、<code v-pre>e.waitUntil()</code>等待 service worker 安装完成、Cache API 开启了一个缓存，并且将我们的应用所需要缓存的文件全部添加进去，当我们再次加载这些资源时，由请求 URL 确定的对应缓存就是可用的。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[Service Worker] Install'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[Service Worker] Caching all: app shell and content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>contentToCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>API 介绍：
<ul>
<li><code v-pre>e.waitUntil()</code>：等待 service worker 安装完成。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ExtendableEvent/waitUntil" target="_blank" rel="noopener noreferrer"><code v-pre>ExtendableEvent.waitUntil</code><ExternalLinkIcon/></a>方法告诉事件分发器该事件仍在进行。这个方法也可以用于检测进行的任务是否成功。在服务工作线程中，这个方法告诉浏览器事件一直进行，直至 promise 解决，浏览器不应该在事件中的异步操作完成之前终止服务工作线程。
<ul>
<li><code v-pre>caches</code> 是一个特殊的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener noreferrer"><code v-pre>CacheStorage</code><ExternalLinkIcon/></a> 对象，它能在 Service Worker 指定的范围内提供数据存储的能力。因为 Web Storage 的执行是同步的，在 Service Worker 中使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener noreferrer">Web Storage<ExternalLinkIcon/></a> 将不会有效果，所以我们使用 Cache API 作为替代。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>激活：</strong> 监听<code v-pre>activate</code> 事件。删除那些我们已经不需要的文件或者做一些清理工作。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> currentCaches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">PRECACHE</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//遍历缓存,查找不存在于自定义缓存列表中的浏览器缓存，并清除</span>
  event<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cacheNames</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token comment">//查找缓存</span>
      <span class="token keyword">return</span> cacheNames<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">cacheName</span> <span class="token operator">=></span> <span class="token operator">!</span>currentCaches<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cachesToDelete</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>cachesToDelete<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">cacheToDelete</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> caches<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>cacheToDelete<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//清除缓存</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>**响应请求：**通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent" target="_blank" rel="noopener noreferrer"><code v-pre>FetchEvent</code><ExternalLinkIcon/></a> 事件去响应请求。通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith" target="_blank" rel="noopener noreferrer"><code v-pre>FetchEvent.respondWith</code><ExternalLinkIcon/></a> 方法，你可以任意修改对于这些请求的响应。拦截页面请求，现在缓存中查找，未找到才去请求。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handling fetch event for'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//事件处理程序侦听 fetch 事件。当触发时返回一个promise给受控页面。</span>
  event<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    <span class="token comment">// promise在 Cache 对象中查询第一个匹配URL请求。如果没有发现匹配项，该代码将转而从网络获取响应。</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Found response in cache:'</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> response<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'No response found in cache. About to fetch from network...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Response from network is:'</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> response<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Fetching failed:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener noreferrer">Service Worker API MDN<ExternalLinkIcon/></a></li>
</ul>
<h4 id="消息推送" tabindex="-1"><a class="header-anchor" href="#消息推送" aria-hidden="true">#</a> 消息推送</h4>
<ul>
<li>
<p>在 Service Worker 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API" target="_blank" rel="noopener noreferrer">推送 API<ExternalLinkIcon/></a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API" target="_blank" rel="noopener noreferrer">通知 API<ExternalLinkIcon/></a>实现。</p>
<ul>
<li>推送 API 可以用来从服务端推送新的内容而无需客户端介入，它是由应用的 Service Worker 来实现的；</li>
<li>通知功能则可以通过 Service Worker 来向用户展示一些新信息，或者至少提醒用户应用已经更新了某些功能。</li>
<li>这些工作是在浏览器外部实现的，所以即使应用被隐藏到后台甚至被关闭了，我们仍然能够推送更新或者通知给用户。</li>
</ul>
</li>
<li>
<p>通知实现：</p>
<ul>
<li>注册 Service Worker 成功后，为了能够显示通知，我们需要先请求用户的授权，一旦用户选择授权，这个授权结果对通知 API 和推送 API 两者都有效。</li>
<li>创建通知：<code v-pre>new Notification(notifTitle, options);</code></li>
</ul>
</li>
<li>
<p>消息推送实现：</p>
<ul>
<li>
<p>注册 Service Worker 成功后，立即开启该客户端的消息推送订阅功能</p>
<ul>
<li>
<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PushManager" target="_blank" rel="noopener noreferrer"><code v-pre>PushManager</code><ExternalLinkIcon/></a> 来订阅新用户。这个方法支持传递两个参数：</p>
<ul>
<li>第一个是 <code v-pre>userVisibleOnly: true</code>，意思是发送给用户的所有通知对他们都是可见的</li>
<li>第二个是 <code v-pre>applicationServerKey</code>，这个参数包含我们之前从服务端取得并转化的 VAPID key。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code><span class="token keyword">return</span> registration<span class="token punctuation">.</span>pushManager<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">userVisibleOnly</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">applicationServerKey</span><span class="token operator">:</span> convertedVapidKey
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>为了方便之后的推送，为每个客户端简单生成一个标识</p>
</li>
<li>
<p>最后，将生成的客户端订阅信息存储在自己的服务器上：使用 fetch 将 subscription 以 JSON 的方式发送给服务器。</p>
</li>
</ul>
</li>
</ul>
<h4 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener noreferrer">渐进式 Web 应用 MDN<ExternalLinkIcon/></a></p>
<p><a href="https://segmentfault.com/a/1190000012353473" target="_blank" rel="noopener noreferrer">PWA实现<ExternalLinkIcon/></a></p>
<p><a href="https://lavas-project.github.io/pwa-book/" target="_blank" rel="noopener noreferrer">《PWA 应用实战》<ExternalLinkIcon/></a></p>
<h3 id="前端渲染模式" tabindex="-1"><a class="header-anchor" href="#前端渲染模式" aria-hidden="true">#</a> 前端渲染模式</h3>
<ul>
<li>前端渲染主要为从服务到浏览器，根据页面渲染方式划分。</li>
</ul>
<p><img src="@source/images/front-end-render.png" alt=""></p>
<h4 id="静态页面渲染-static-rendering" tabindex="-1"><a class="header-anchor" href="#静态页面渲染-static-rendering" aria-hidden="true">#</a> 静态页面渲染（Static Rendering）</h4>
<ul>
<li>
<p>概念：静态渲染就是直接用已经成型的html文件进行渲染，将生成 HTML 页面的工作放到编译时，而不必在请求带来时动态完成。会有一些辅助的JS来增强页面交互；</p>
<p><img src="@source/images/static-render.jpg" alt=""></p>
</li>
<li>
<p>优点：</p>
<ul>
<li>性能参数都比较优异，TTFB 和 FP 和 FCP几乎相同；</li>
<li>适合CDN部署；</li>
<li>客户端与服务端压力都比较小；</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>必须为每个可能的URL生成单独的HTML文件。 当无法提前预测这些URL的URL或具有大量唯一页面的网站时，这可能具有挑战性甚至不可行, 如果是纯手工开发，那开发效率相对也比较低。</li>
<li>只适用于偏静态内容：对于动态的、个性化的内容作用不大</li>
</ul>
</li>
</ul>
<h4 id="预渲染" tabindex="-1"><a class="header-anchor" href="#预渲染" aria-hidden="true">#</a> 预渲染</h4>
<ul>
<li>概念：
<ul>
<li>预渲染是通过启动一个无头浏览器(headless browser)，加载应用程序的路由并将结果保存到静态HTML文件中。</li>
<li>预渲染并不需要服务端支持，它只能生成在 templete 写好的 dom 结构,也就是只能生成静态的 html 文件。</li>
<li>预渲染必须经客户端渲染才真正可交互。</li>
<li>一般是每个路由对应一个静态的 html 文件，在服务器获取时就已经生成好了，而不需要 diff 再动态生成 dom。
<ul>
<li>补充知识：Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，爬虫抓取信息等。</li>
</ul>
</li>
</ul>
</li>
<li>应用场景：
<ul>
<li>针对特定路由的静态 HTML 文件。如：营销页面（例如<code v-pre>/</code>,<code v-pre>/about</code>,<code v-pre>/contact</code>等）。</li>
<li>配置骨架屏。当ajax获取到数据之后把骨架屏替换掉，可以减少白屏时间。</li>
</ul>
</li>
<li>不适用场景：
<ul>
<li>大量路由场景。 如果您的站点有成百上千个路由，则预渲染将非常缓慢。当然，每个更新只需要执行一次，但是可能要花一些时间。大多数人并没有最终获得数千个静态网页，而是以防万一。</li>
<li>动态内容。 如果您的渲染页面包含特定于用户查看其内容或其他动态源的内容，则应确保拥有可以显示的占位符组件，直到动态内容加载到客户端为止。否则可能有点怪异。</li>
</ul>
</li>
<li>与服务端渲染区别：
<ul>
<li>服务端渲染的过程为：服务端获取后端数据 -&gt; 解析执行JS -&gt; 构建HTML页面 -&gt; 输出完整的带数据 HTML 页面给浏览器。</li>
<li>预渲染：直接输出 HTML 结构的页面给浏览器，HTML 页面中只有页面结构或静态内容，没有后端数据内容和 不执行JS。</li>
</ul>
</li>
<li>常用插件： <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener noreferrer">prerender-spa-plugin<ExternalLinkIcon/></a></li>
<li>参考资料：
<ul>
<li><a href="https://tech.meituan.com/2018/11/15/first-contentful-paint-practice.html" target="_blank" rel="noopener noreferrer">构建时预渲染：网页首帧优化实践<ExternalLinkIcon/></a></li>
</ul>
</li>
</ul>
<h4 id="客户端渲染-csr" tabindex="-1"><a class="header-anchor" href="#客户端渲染-csr" aria-hidden="true">#</a> 客户端渲染（CSR）</h4>
<ul>
<li>
<p>概念：Client-side rendering (CSR) ，一种纯在客户端(浏览器)利用JS操作Dom渲染页面的方式. 所有的生成逻辑, 数据获取, 模板 and 路由 都由浏览器而不是服务端来控制。</p>
<p><img src="@source/images/csr.jpg" alt=""></p>
<ul>
<li>
<p>客户端渲染是当前最流行的渲染模式，常以SPA单页面应用的方式存在；通常使用 VUE 开发的单页面应用一般为客户端渲染；</p>
</li>
<li>
<p>与后端的交互主要为API服务接口的数据调用，得到数据后在浏览器中通过 JS 进行模板编译、渲染、页面更新、路由等操作。</p>
</li>
<li>
<p>除了TTFB短，其他都会被延长，可以通过Http2的服务端推送与<code v-pre>&lt;link rel=preload&gt;</code>来提升FCP；</p>
</li>
<li>
<p>由于JS和CSS的大小会影响首屏的渲染，所以最好做好代码分割，只提供页面渲染必要的资源代码，应用懒加载的形式来提供其余的资源时非常有必要的；</p>
</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>允许在导航到不同页面时几乎立即在浏览器中更新网站，更新速度快。</li>
<li>但在开始时需要更多的初始下载和客户端上的额外渲染。 首次访问时网站速度较慢，但后续访问速度要快得多。</li>
<li>天然的浏览器分布式环境</li>
<li>组件复用度高，还可以通过懒加载等进行性能的进一步优化</li>
<li>除首屏外性能响应快速</li>
<li>WEB/MOBILE多端渲染</li>
<li>前后端分离开发</li>
</ul>
</li>
</ul>
<ul>
<li>缺点：
<ul>
<li>首屏性能差：由于页面渲染、三方包等逻辑都置于一个JS文件中，首屏加载会导致一定时间的白屏现象。</li>
<li>浏览器SEO性能差：由于现阶段大多搜索引擎采用的爬虫算法是直接抓取页面代码分析，而 SPA 应用只有一个入口文件而没实质内容，内容通过获取后端数据接口通过浏览器端 JS 解析渲染，而搜索引擎不能抓取异步解析的数据。</li>
</ul>
</li>
</ul>
<h4 id="服务端渲染-ssr" tabindex="-1"><a class="header-anchor" href="#服务端渲染-ssr" aria-hidden="true">#</a> 服务端渲染（SSR）</h4>
<ul>
<li>
<p>概念：Server-Side Rendering - 就是服务端渲染出HTML页面。</p>
<p><img src="@source/images/ssr.jpg" alt=""></p>
<ul>
<li>在不同页面之间导航需要下载新的HTML，首页会从缓存中获取已渲染页面，为查找到则服务端重新渲染。</li>
<li>服务器上渲染页面：后端不仅仅进行数据的获取处理操作，同时也负责页面的生成，最终传到客户端(浏览器)的是生成的包含数据的页面。</li>
<li>客户端所需要做的仅仅是html页面的展现和之后的DOM事件处理。</li>
<li>除了TTFB会延长（服务端需要去准备相应的页面数据），其他三个性能参数都比较客观；</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>SEO 友好：页面是在服务端渲染好的静态页面，便于爬虫抓取信息。</li>
<li>更好的性能数据，客户端压力更。</li>
<li>首屏加载快，跨浏览器兼容性良好，但代价是页间加载时间延长，也就是总体感知上的性能降低：每加载一个页面，都需要一个服务器请求往返的时间。</li>
</ul>
</li>
</ul>
<ul>
<li>缺点：
<ul>
<li>在不同页面之间导航都需要下载新的HTML内容导致页面切换无法渐进式加载，每个页面都需要重新渲染，页面切换时不能定义过渡动画(间隔有白屏，Chrome 在同域名页面跳转时，有一个<a href="https://developers.google.com/web/updates/2019/05/paint-holding" target="_blank" rel="noopener noreferrer">PLS优化<ExternalLinkIcon/></a>，即延迟到下一个页面FCP节点时开始下一个页面的渲染)；</li>
<li>服务器负载大：由于渲染任务都交由服务端进行，在高并发的情况下，对于服务端负载压力大，同时丧失了浏览器端作为一个天然分布式系统的优势。</li>
<li>复用性能差：因为返回的是整个页面，对于每个路由都要重新进行页面刷新，复用性能上不友好。</li>
<li>前后端耦合严重，前端开发依赖于后端，开发形式上不友好，属于前后端不分离模式。</li>
</ul>
</li>
</ul>
<h4 id="同构渲染" tabindex="-1"><a class="header-anchor" href="#同构渲染" aria-hidden="true">#</a> 同构渲染</h4>
<ul>
<li>
<p>概念：同构是 SSR+CSR 的合体。首屏的html页面由服务端提供，然后加载 js，js 利用现有的 dom 树来接管渲染后页面的交互操作，跳转到新页面时就变成纯CSR渲染。</p>
<p><img src="@source/images/rehydretion.jpg" alt=""></p>
<ul>
<li>前后端共用一套 JS 代码，采用不同的构建方式，应用程序的大部分代码都可以在服务器和客户端上运行。</li>
<li>通过Node服务器进行页面的首屏生成，在服务器上渲染网站，缓存其内容，然后在客户端需要时更新渲染。</li>
<li>使用了 SSR，第一页加载很快；因为客户端可以仅使用已更改的部分重新渲染页面，所以页面之间的导航也是平滑的。</li>
<li>将同一个组件渲染为服务器端的 HTML 字符串和渲染数据，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。激活后在客户端交给客户端脚本处理。
<ul>
<li>服务端渲染后的内容包括 的 HTML 字符串和渲染数据：<img src="@source/images/ssr2.png" alt=""></li>
</ul>
</li>
<li><code v-pre>bundle.js</code>仍然是全量的 CSR 代码，这些代码执行完毕页面才真正可交互。因此，这种模式下，FP（First Paint）虽然有所提升，但 TTI（Time To Interactive）可能会变慢，因为在客户端二次渲染完成之前，页面无法响应用户输入（被 JS 代码执行阻塞了）</li>
<li>是一种比较有技术含量的渲染方式，当下比较流行的NextJs(React), NuxtJs(Vue)就是这种渲染技术的成熟框架。</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>利于SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li>
<li>结合了SSR与CSR的特点，首屏之后的页面交互可实现渐进式加载，可控性高。</li>
<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。
<ul>
<li>无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。</li>
<li>通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li>
<li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li>
<li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
<li>技术要求更高（包含代码处理），同时对服务器和客户端都有性能要求；</li>
<li>通过服务端 <code v-pre>html</code> 生成方法 <code v-pre>renderToString</code> 是同步的，这会阻塞 Node 服务主线程；使用 <code v-pre>renderToNodeStream</code> 是异步的，服务端压力相对而言就没那么大。</li>
</ul>
</li>
</ul>
<h4 id="trisomorphic-rendering" tabindex="-1"><a class="header-anchor" href="#trisomorphic-rendering" aria-hidden="true">#</a> Trisomorphic Rendering</h4>
<ul>
<li>
<p>概念：把Service Worker也考虑进来的话，还有一种<em>涉及三方的渲染模式</em>：</p>
<p><img src="@source/images/Trisomorphic-Rendering.png" alt=""></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><pre v-pre class="language-javascript"><code><span class="token constant">SSR</span> <span class="token operator">+</span> <span class="token constant">CSR</span> <span class="token operator">+</span> ServiceWorker rendering <span class="token operator">=</span> Trisomorphic Rendering
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>首先通过流式 SSR 渲染初始页面，接着由 Service Worker 根据路由规则，借助 SSR 渲染出目标 HTML 页面。</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>跨三方共享模板渲染和路由控制逻</li>
</ul>
</li>
</ul>
<h4 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h4>
<p><img src="@source/images/应用比较.png" alt=""></p>
<p><strong>参考资料</strong></p>
<p><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#:~:text=%20Rendering%20on%20the%20Web%20%201%20Terminology.,Paint%2C%20First%20Contentful%20Paint%20and%20Time...%20More%20" target="_blank" rel="noopener noreferrer">Rendering on the Web<ExternalLinkIcon/></a></p>
<h2 id="vue-ssr-1" tabindex="-1"><a class="header-anchor" href="#vue-ssr-1" aria-hidden="true">#</a> VUE SSR</h2>
<p>基于官文demo：<a href="https://github.com/vuejs/vue-hackernews-2.0/" target="_blank" rel="noopener noreferrer">HackerNews Demo<ExternalLinkIcon/></a> 进行分析，项目结构等基础参考 <a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener noreferrer">vue-ssr 文档<ExternalLinkIcon/></a>。</p>
<h3 id="vue-ssr-流程" tabindex="-1"><a class="header-anchor" href="#vue-ssr-流程" aria-hidden="true">#</a> VUE SSR 流程</h3>
<ul>
<li>开发环境下执行流程</li>
</ul>
<p><img src="@source/flow-graph/ssr过程.png" alt=""></p>
<ul>
<li>SSR 流程主要分为：
<ul>
<li>服务端渲染</li>
<li>客户端渲染</li>
</ul>
</li>
<li>服务端渲染
<ul>
<li>渲染时机：
<ul>
<li>通过 express 服务渲染：浏览器输入 url 直接定向到某个页面，express 执行 <code v-pre>entry-server.js</code> 动态渲染 Html</li>
<li>静态化页面时，通过执行 <code v-pre>entry-client.js</code> 渲染出 html 页面</li>
</ul>
</li>
<li>总体流程：
<ul>
<li>浏览器输入 url -&gt;  express 服务接受请求 -&gt; 服务端获取数据 -&gt; 数据注入 store -&gt; SSR Renderer 渲染HTML页面 -&gt; 返回浏览器</li>
</ul>
</li>
</ul>
</li>
<li>客户端渲染
<ul>
<li>渲染时机： 通过页面中链接切换路由</li>
<li>总体流程：首次渲染时由服务端渲染，客户端激活后通过路由导航的所有页面又客户端渲染。
<ul>
<li>页面内点击链接 -&gt; 客户端获取数据 -&gt; 渲染页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ssr-注意事项" tabindex="-1"><a class="header-anchor" href="#ssr-注意事项" aria-hidden="true">#</a> SSR 注意事项</h3>
<ul>
<li>服务端渲染时，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用响应式数据。避免将「数据」转换为「响应式对象」的性能开销。</li>
<li>所有的生命周期钩子函数中，只有 <code v-pre>beforeCreate</code> 和 <code v-pre>created</code> 会在服务器端渲染 (SSR) 过程中被调用。任何其他生命周期钩子函数中的代码（例如 <code v-pre>beforeMount</code> 或 <code v-pre>mounted</code>），只会在客户端执行。
<ul>
<li>为什么只有<code v-pre>beforeCreate</code> 和 <code v-pre>created</code> 会在服务器端渲染 (SSR) 过程中被调用？
<ul>
<li>服务端渲染过程中不需要响应式数据，没有动态更新过程；</li>
<li>服务端渲染在VUE初始化时仅仅 new VUE 实例，不需要挂载（$mount）实例，因此不会执行 $mount 之后流程；</li>
<li>客户端动态请求的数据/内容 需要在 mounted 函数中执行（如：动态获取用户数据）</li>
</ul>
</li>
</ul>
</li>
<li>对于仅浏览器可用的 API，通常方式是，在「纯客户端 (client-only)」的生命周期钩子函数 <code v-pre>beforeMounte</code>、<code v-pre>mounted</code> 中惰性访问 (lazily access) 它们。</li>
<li>应该避免在 <code v-pre>beforeCreate</code> 和 <code v-pre>created</code> 生命周期时产生全局副作用的代码。
<ul>
<li>例如在其中使用 <code v-pre>setInterval</code> 设置 time，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来</li>
</ul>
</li>
<li>服务端和浏览器通用代码不可接受特定平台的 API：
<ul>
<li>如果通用代码中，直接使用了仅浏览器可用的全局变量 <code v-pre>window</code> 或 <code v-pre>document</code>，则会在 Node.js 中执行时抛出错误；</li>
<li>通用代码使用 Node.js 平台特定 API，如<code v-pre>global</code>，则会在浏览器中执行报错；</li>
</ul>
</li>
<li>大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误；</li>
<li>静态函数 <code v-pre>asyncData</code>无法访问 <code v-pre>this</code>，因为此函数会在组件实例化之前调用；</li>
<li>服务端渲染时不需要响应式数据，默认禁用响应式数据，可以避免将「数据」转换为「响应式对象」的性能开销；</li>
<li>模板中的<code v-pre>&lt;!--vue-ssr-outlet--&gt;</code> 注释 部分是 renderer 渲染 HTML 字符串插入的位置；</li>
</ul>
<h3 id="参考资料-1" tabindex="-1"><a class="header-anchor" href="#参考资料-1" aria-hidden="true">#</a> 参考资料</h3>
<p><a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener noreferrer">vue-ssr 文档<ExternalLinkIcon/></a></p>
</div></template>


